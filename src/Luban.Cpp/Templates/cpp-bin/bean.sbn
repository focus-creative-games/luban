{{get_beans_includes __export_fields}}
{{if __parent_def_type}}
    #include "{{__parent_def_type.full_name}}.h"
{{end}}
{{namespace_with_grace_begin __namespace_with_top_module}}
{{~if __this.comment != '' ~}}
/**
 * {{escape_comment __this.comment}}
 */
{{~end~}}
struct {{__name}} : public{{if __parent_def_type}} {{make_cpp_name __parent_def_type.full_name}} {{else}} luban::CfgBean {{end}}
{
    static bool deserialize{{__name}}(::luban::ByteBuf& _buf, {{__name}}& _out)
    {
    {{~if __this.is_abstract_type~}}
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
        {{~for child in __this.hierarchy_not_abstract_children~}}
            case {{make_type_cpp_name child}}::__ID__: { return static_cast<{{make_type_cpp_name child}}&>(_out).deserialize(_buf); }
        {{~end~}}
            default: { return false;}
        }
    {{~else~}}
        return _out.deserialize(_buf);
    {{~end~}}
    }

    virtual ~{{__name}}() {} 

    bool deserialize(::luban::ByteBuf& _buf)
    {
        {{~if __this.parent_def_type~}}
        if (!{{make_cpp_name __this.parent_def_type.full_name}}::deserialize(_buf))
        {
            return false;
        }
        {{~end~}}
    
        {{~ for field in __this.export_fields ~}}
        {{deserialize '_buf' (format_field_name __code_style field.name) field.ctype}}
        {{~end~}}
    
        return true;
    }

    {{~ for field in __export_fields ~}}
{{~if field.comment != '' ~}}
    // {{escape_comment field.comment}}
{{~end~}}
    {{declaring_type_name field.ctype}} {{format_field_name __code_style field.name}};
    {{~end~}}

{{~if !__this.is_abstract_type~}}
    static constexpr int __ID__ = {{__this.id}};

    int getTypeId() const override { return __ID__; }
{{~end~}}
};
{{namespace_with_grace_end __namespace_with_top_module}}
